theory Lee_Test
begin

builtins: rerandomizable-encryption
// functions: sign/2, checksign/2, dvp/4, checkdvp/4, pk/1 //, renc/3, rdec/2, rerand/3, rpk/1, radd/2
functions: sign/2, checksign/2, dvp/4, checkdvp/4, pk/1
equations:
    // rdec(renc(m, r, rpk(sk)), sk) = m,
    // rerand(renc(m, r1, rpk(sk)), r2, rpk(sk)) = renc(m, radd(r1,r2), rpk(sk)),
    checksign( sign(m, sk), pk(sk)) = m,
    checkdvp(dvp(x, renc(x, r, pk(sk1)), r, pk(sk2)), x, renc(x, r, pk(sk1)), pk(sk2)) = r

rule Register_Voter_pk:
    [ Fr(~ltkV) ] --[ ]-> [ !Ltk($V, ~ltkV), !Pk($V, pk(~ltkV)), Out(pk(~ltkV)) ]

rule Register_Admin_pk:
    [ Fr(~ltkA) ] --[ ]-> [ !AdminLtk($A, ~ltkA), !AdminPk($A, pk(~ltkA)), Out(pk(~ltkA)) ]

rule Register_Tallyer_pk:
    [ Fr(~ltkT) ] --[ ]-> [ !TallyerLtk($T, ~ltkT), !TallyerPk($T, pk(~ltkT)), Out(pk(~ltkT)) ]

rule V_1:
  let e = renc($vote, ~r, pk(~ltkT))
      s = sign(e, ~ltkV)
  in
    [ Fr(~r), !TallyerPk(T, pk(~ltkT)), !Ltk(V, ~ltkV) ]
  --[ Voted($vote), Create_V_1(e) ]->
    [ Out(<e, s>), State_V_1(V, ~ltkV, $vote, ~r, T, ~ltkT) ]

rule A_1:
  let ea = rrand(e, ~ra, pk(~ltkT))
      sa = sign(ea, ~ltkA)
      dvp_p = dvp(e, ea, ~ra, pk(~ltkV))
  in
    [ Fr(~ra), In(<e, sign(e, ~ltkV)>), !TallyerPk(A, pk(~ltkT)), !AdminLtk(A, ~ltkA), !Pk(V, pk(~ltkV)), State_V_1(V, ~ltkV, $vote, r, T, ~ltkT) ]
  --[ ValidVoterSig(e, sign(e, ~ltkV)), Registered(ea) ]->
    [ Out(<ea, sa, dvp_p>), State_A_1(V, A, e, ~ra) ]

rule T_1:
    let v = rdec(ea, ~ltkT)
    in
    [ In(<ea, sign(ea, ~ltkA)>), !AdminPk(A, pk(~ltkA)), !TallyerLtk(T, ~ltkT) ]
  --[ ValidAdminSig_T(ea, sign(ea, ~ltkA)), VotePublished(v) ]->
    [ Out(v) ]

lemma exec:
    exists-trace
    " Ex e #i. VotePublished(e) @i "

end
